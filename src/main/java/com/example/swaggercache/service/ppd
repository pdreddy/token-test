@ExtendWith(MockitoExtension.class)
class CertificateControllerTest {

    @InjectMocks
    private CertificateController certificateController;

    @Mock
    private CertificateService certificateService;

    @Mock
    private HttpServletRequest httpServletRequest;

    @Mock
    private Principal mockPrincipal;

    @BeforeEach
    void setup() {
        when(httpServletRequest.getUserPrincipal()).thenReturn(mockPrincipal);
        when(mockPrincipal.getName()).thenReturn("admin_user");
    }

    @Test
    void testFindAllCerts_Success() {
        List<CertificateResponse> responses = List.of(new CertificateResponse());
        when(certificateService.getAllCertificates()).thenReturn(responses);

        ResponseEntity<List<CertificateResponse>> response = certificateController.findAllCerts(httpServletRequest);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(1, response.getBody().size());
    }

    @Test
    void testGetCertificatesByClientId_Success() {
        List<CertificateResponse> responses = List.of(new CertificateResponse());
        when(certificateService.getCertificatesByClientId("client123")).thenReturn(responses);

        ResponseEntity<List<CertificateResponse>> response = certificateController.getCertificatesByClientId("client123");

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(1, response.getBody().size());
    }

    @Test
    void testGetJwks_Success() {
        CertificateResponse response = new CertificateResponse();
        response.setJwk("{\"kty\":\"RSA\"}");

        when(certificateService.getCertificatesByClientId("client123"))
            .thenReturn(List.of(response));

        ResponseEntity<String> jwks = certificateController.getJwks("client123");

        assertEquals(HttpStatus.OK, jwks.getStatusCode());
        assertTrue(jwks.getBody().contains("kty"));
    }

    @Test
    void testGetJwks_WithErrorInJWK() {
        CertificateResponse response = new CertificateResponse();
        response.setJwk("invalid");

        when(certificateService.getCertificatesByClientId("client123"))
            .thenReturn(List.of(response));

        ResponseEntity<String> jwks = certificateController.getJwks("client123");

        assertEquals(HttpStatus.OK, jwks.getStatusCode());
    }

    @Test
    void testSaveCert_Success() throws Exception {
        String samplePem = "-----BEGIN CERTIFICATE-----\n" +
                           Base64.getEncoder().encodeToString("test".getBytes()) +
                           "\n-----END CERTIFICATE-----";

        when(mockPrincipal.getName()).thenReturn("admin_user");

        CertificateResponse response = new CertificateResponse();
        when(certificateService.saveCertificate(any())).thenReturn(response);

        ResponseEntity<?> result = certificateController.saveCert("clientId", samplePem, httpServletRequest, "clientId");

        assertEquals(HttpStatus.CREATED, result.getStatusCode());
    }

    @Test
    void testSaveCert_InvalidClientId() throws Exception {
        String samplePem = "-----BEGIN CERTIFICATE-----\n" +
                           Base64.getEncoder().encodeToString("test".getBytes()) +
                           "\n-----END CERTIFICATE-----";

        ResponseEntity<?> result = certificateController.saveCert("clientId", samplePem, httpServletRequest, "wrongClientId");

        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());
        assertTrue(result.getBody().toString().contains("Invalid Client ID"));
    }

    @Test
    void testSaveCert_Exception() throws Exception {
        String invalidPem = "invalid-pem";

        ResponseEntity<?> result = certificateController.saveCert("clientId", invalidPem, httpServletRequest, "clientId");

        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());
        assertTrue(result.getBody().toString().contains("Failed to process certificate"));
    }
}


@ExtendWith(MockitoExtension.class)
class CertificateServiceTest {

    @InjectMocks
    private CertificateService certificateService;

    @Mock
    private CertificateRepository certificateRepository;

    @Mock
    private RedisTemplate<String, String> redisTemplate;

    @Mock
    private ObjectMapper objectMapper;

    @Mock
    private ValueOperations<String, String> valueOperations;

    @BeforeEach
    void setup() {
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
    }

    @Test
    void testSaveCertificate_Success() throws Exception {
        CertificateRequest request = new CertificateRequest();
        request.setClientId("client1");

        X509Certificate x509Cert = mock(X509Certificate.class);
        when(x509Cert.getSerialNumber()).thenReturn(BigInteger.valueOf(12345));
        when(x509Cert.getEncoded()).thenReturn("cert".getBytes());
        when(x509Cert.getPublicKey()).thenReturn(mock(RSAPublicKey.class));
        when(x509Cert.getNotBefore()).thenReturn(new Date());
        when(x509Cert.getNotAfter()).thenReturn(new Date(System.currentTimeMillis() + 100000));
        when(x509Cert.getSubjectX500Principal()).thenReturn(new X500Principal("CN=demo"));

        request.setX509Cert(x509Cert);

        when(certificateRepository.existsByClientIdAndCertSerialNumber(eq("client1"), eq(12345L)))
                .thenReturn(false);

        Certificate saved = Certificate.builder()
                .clientId("client1")
                .certSerialNumber(12345L)
                .certSubject("demo")
                .build();

        when(certificateRepository.save(any(Certificate.class))).thenReturn(saved);

        CertificateResponse response = certificateService.saveCertificate(request);
        assertNotNull(response);
        assertEquals("client1", response.getClientId());
    }

    @Test
    void testSaveCertificate_AlreadyExists_Throws() {
        CertificateRequest request = new CertificateRequest();
        request.setClientId("client1");

        X509Certificate x509Cert = mock(X509Certificate.class);
        when(x509Cert.getSerialNumber()).thenReturn(BigInteger.valueOf(12345));
        when(x509Cert.getEncoded()).thenReturn("cert".getBytes());
        request.setX509Cert(x509Cert);

        when(certificateRepository.existsByClientIdAndCertSerialNumber("client1", 12345L))
                .thenReturn(true);

        RuntimeException ex = assertThrows(RuntimeException.class, () ->
                certificateService.saveCertificate(request));

        assertTrue(ex.getMessage().contains("already associated"));
    }

    @Test
    void testSaveCertificate_ThrowsException() throws Exception {
        CertificateRequest request = new CertificateRequest();
        request.setClientId("client1");

        X509Certificate x509Cert = mock(X509Certificate.class);
        when(x509Cert.getSerialNumber()).thenReturn(BigInteger.valueOf(12345));
        when(x509Cert.getEncoded()).thenThrow(new CertificateEncodingException());
        request.setX509Cert(x509Cert);

        assertThrows(RuntimeException.class, () -> certificateService.saveCertificate(request));
    }

    @Test
    void testGetCertificatesByClientId_FromRedisSuccess() throws Exception {
        String clientId = "client1";
        String cacheKey = "CACHE::CLIENT::client1";
        String cachedJson = "[{\"clientId\":\"client1\"}]";
        List<Certificate> certList = List.of(new Certificate());

        when(valueOperations.get(cacheKey)).thenReturn(cachedJson);
        when(objectMapper.getTypeFactory()).thenReturn(new ObjectMapper().getTypeFactory());
        when(objectMapper.readValue(eq(cachedJson), any(JavaType.class))).thenReturn(certList);

        List<CertificateResponse> responses = certificateService.getCertificatesByClientId(clientId);

        assertEquals(1, responses.size());
    }

    @Test
    void testGetCertificatesByClientId_FallbackToDB() throws Exception {
        String clientId = "client1";
        String cacheKey = "CACHE::CLIENT::client1";

        when(valueOperations.get(cacheKey)).thenReturn(null);

        List<Certificate> certList = List.of(new Certificate());
        when(certificateRepository.findByClientIdOrderByCreatedDateDesc(clientId))
                .thenReturn(certList);

        when(objectMapper.writeValueAsString(certList)).thenReturn("[]");

        List<CertificateResponse> responses = certificateService.getCertificatesByClientId(clientId);

        assertEquals(1, responses.size());
        verify(valueOperations).set(cacheKey, "[]");
    }

    @Test
    void testGetCertificatesByClientId_JsonProcessingException() throws Exception {
        String clientId = "client1";
        String cachedData = "[{invalid-json}]";

        when(valueOperations.get(anyString())).thenReturn(cachedData);
        when(objectMapper.getTypeFactory()).thenReturn(new ObjectMapper().getTypeFactory());
        when(objectMapper.readValue(eq(cachedData), any(JavaType.class)))
                .thenThrow(JsonProcessingException.class);

        when(certificateRepository.findByClientIdOrderByCreatedDateDesc(clientId))
                .thenReturn(List.of());

        when(objectMapper.writeValueAsString(any())).thenReturn("[]");

        List<CertificateResponse> responses = certificateService.getCertificatesByClientId(clientId);
        assertEquals(0, responses.size());
    }

    @Test
    void testGetAllCertificates() {
        List<Certificate> certList = List.of(new Certificate(), new Certificate());
        when(certificateRepository.findAll()).thenReturn(certList);

        List<CertificateResponse> responses = certificateService.getAllCertificates();
        assertEquals(2, responses.size());
    }

    @Test
    void testCacheCertificateInCluster_Success() throws Exception {
        Certificate cert = Certificate.builder()
                .clientId("client1")
                .jwtTxt("xyz.jwt.token")
                .build();

        when(objectMapper.writeValueAsString(any())).thenReturn("{json}");

        certificateService.cacheCertificateInCluster(cert);

        verify(redisTemplate).delete("CACHE::CLIENT::client1");
        verify(valueOperations).set(startsWith("CACHE::LOOKUP::"), "{json}");
    }

    @Test
    void testCacheCertificateInCluster_JsonException() throws Exception {
        Certificate cert = Certificate.builder().clientId("client1").jwtTxt("jwt").build();

        when(objectMapper.writeValueAsString(any())).thenThrow(JsonProcessingException.class);

        certificateService.cacheCertificateInCluster(cert);
        verify(redisTemplate, never()).delete(any());
    }
}

